# Ticketfly Metrics

This addon is a wrapper around [`ember-metrics`](https://github.com/poteto/ember-metrics) that gives some
default behavior for Ticketfly Ember apps to use our metrics collection service, Segment, and our monitoring
service, New Relic.

There are three parts of this addon for using, testing, and deploying with metrics collection.

## Installation

This package will need to be installed from Github (as we are not yet publishing to npm). After installing,
be sure to run the default blueprint (this will give you the test helpers specified below).

```sh
ember install Ticketfly/ticketfly-metrics
ember generate ticketfly-metrics default
```

## Track Routing by Default

If you would like your application to automatically track all page transitions, then in your `router.js` file,
replace Ember's router with the `ticketfly-metrics` router:

```js
// router.js
import EmberRouter from 'ticketfly-metrics/router';
import config from './config/environment';

const Router = EmberRouter.extend({
  location: config.locationType,
  rootURL: config.rootURL
});

Router.map(function() {
  this.route('metrics', { path: 'my-metrics' });
});

export default Router;
```

When you add router tracking, for every transition, a `trackPage` event will be triggered with two attributes:

* `page`: This is the URL (excluding the host) of the page
* `title`: This is the name of the route. Something like `transfers.new.index`

If you want to customize the track page so that it includes contextual information based on the model of the route,
you can add a `metricsForModel` hook to your route.

Let's assume this is our route for `metrics`:

```js
// app/routes/metrics.js
export default Route.extend({
  model() {
    return { name: 'Spencer' };
  },

  metricsForModel(model) {
    return {
      name: model.name
    };
  }
});
```

Then, when you hit this route, the object that gets passed to `trackPage` would be:

```js
{
  page: '/my-metrics',
  title: 'metrics',
  name: 'Spencer'
}
```

If your model is asynchronous, then you can return a promise from `metricsForModel` and that will delay the
`trackPage` event to be fired until after the model has resolved.

You may also use the `metricsForModel` hook to overwrite the defaults for `page` and `title`.

Please note that this is cascading — so all parent routes will also use the `metricsForModel` hook to
add to the `trackPage` event. It is overwritten so that the leaf route takes precedent.

## Segment Configuration

Adding tracking is opt-in, so you will have to update your `config/environment.js` to use the default
configuration from this addon.

```js
// config/environment.js
const { configSegment } = require('ticketfly-metrics');

module.exports = function(environment) {
  const ENV = {
    // ... Other configuration ...
    metricsAdapters: configSegment(environment, {})
  };
};
```

Using this default configuration will enable you to _test_ for metrics calls (see below) — however,
it will not actually send metrics to any of the metrics services. To do that, we need to get a Segment
key for each of the respective environments that we would like to collect metrics in.

Suppose your keys are:

```txt
Dev (All):  71c42bf0
Stg 02:     8306dd06
Prod 02:    1dd16e15
```

Then, in your configuration, add:

```js
var ENV = {
  metricsAdapters: configSegment(environment, {
    segmentKeys: {
      dev$: '71c42bf0',
      stg02: '8306dd06',
      prod02: '1dd16e15'
    }
  })
};
```

The keys of the options object refer to the `process.env.TFLY_DEPLOY_TARGET` value which is made availalble
during deploys done in Rundeck. (See https://github.com/Ticketfly/ember-cli-deploy-ticketfly) for more
information about deploys.

Adding a `$` to the end of the key enables it to match any environment
that _starts_ with everything preceding it.

Also, if a environment is _not_ specified, then the `metrics` service will not attempt to send
any of these metrics to Segment. However, the testing support will still be available. (This is
useful in an Addon/Engine as it will never send stuff to Segment itself — the host app will.)

## New Relic Configuration

Adding new relic is opt-in, so you will have to update your `config/environment.js` to use the default
configuration from this addon.

```js
// config/environment.js
const { configNewRelic, targets } = require('ticketfly-metrics');

module.exports = function(environment) {
  var ENV = {
    // ... Other configuration ...
    newRelic: configNewRelic(environment, {})
  };
};
```

Using this default configuration will NOT enable New Relic. To do that, we need to get a New Relic
application ID and license key for each of the respective environments that we would like to
monitor.

Suppose your keys are:

```txt
            license Key   ApplicationID
Dev (All):  71c42bf0      898udb2
Stg 02:     8306dd06      12hs823
Prod 02:    1dd16e15      928ju29
```

Then, in your configuration, add:

```js
var ENV = {
  newRelic: configNewRelic(environment, {
    nrKeys: {
      dev$: { licenseKey:'71c42bf0', applicationID: '898udb2' },
      stg02: { licenseKey:'8306dd06', applicationID: '12hs823' },
      prod02: { licenseKey:'1dd16e15', applicationID: '928ju29' }
    }
  })
};
```

The keys of the options object refer to the `process.env.ENVIRONMENT` value which is made availalble
during deploys done in Rundeck. (See https://github.com/Ticketfly/ember-cli-deploy-ticketfly) for more
information about deploys.

Also, if a environment is _not_ specified, then New Relic will not be included on the page.

## Testing

The best way to test the functionality of how/when metrics are generated, you can use the `queryMetrics` test
helper to check to see which metrics have been collected.

There are two assumptions for the following tests — first is that we've used the `ticketfly-router` from above. The second
is that we have the following controller and template:

```js
// app/controllers/my-page.js
import Controller from 'ember-controller';
import service from 'ember-service/inject';
import get from 'ember-metal/get';

export default Controller.extend({
  metrics: service(),

  actions: {
    firstAction() {
      const event = 'Event Numero Uno!';
      get(this, 'metrics').trackEvent({ event });
    },
    secondAction() {
      const event = 'Event Number Two';
      get(this, 'metrics').trackEvent({ event });
    }
  }
});
```

```hbs
{{! app/templates/my-page.hbs }}
<button class="first-action" {{action 'firstAction'}}>
  Do the first thing!
</button>

<button class="second-action" {{action 'secondAction'}}>
  Do the second thing!
</button>

```

```js
// tests/acceptance/my-page-test.js

test('visiting /my-page', function(assert) {
  visit('/my-page');

  andThen(() => {
    const trackPage = queryMetrics('trackPage');

    assert.equal(currentURL(), '/my-page');
    assert.equal(trackPage.length, 1);
    assert.deepEqual(trackPage.first, {
      page: '/my-page',
      title: 'my-page'
    });

    click('.first-action');
    click('.second-action');
  });

  andThen(() => {
    const trackEvent = queryMetrics('trackEvent');
    const uno = trackEvent.where({ event: 'Event Numero Uno!' });

    assert.equal(trackEvent.length, 2, 'there are 2 events');
    assert.ok(uno.first, 'there is a metrics item for event 1');
  });
});
```

The `queryMetrics` supports the four different types of events that `ember-metrics` supports

* `identify`
* `trackEvent`
* `trackPage`
* `alias`

This will return a instance of a database-like class that you can query for the metrics events
that you are checking for.

So, if we had done:

```js
metrics.identify({
  firstName: 'Spencer',
  lastName: 'Price',
  id: '1234'
});

metrics.trackEvent({ event: 'Did the thing.' });
metrics.trackEvent({ event: 'Did the other thing.' });
metrics.trackEvent({ event: 'Did the thing.', show: 'Rufus Wainwright' });
```

Then, these events would be query-able like so:

```js
const identify = queryMetrics('identify').where({
  firstName: 'Spencer'
}).first;

console.log(identify); // { firstName: 'Spencer', lastName: 'Price', id: '1234' }

const shows = queryMetrics('trackEvent').where({ event: 'Did the thing.' });
console.log(shows.length); // 2

const rufusShows = shows.where({ show: 'Rufus Wainwright' });
console.log(rufusShows.length); // 1
```
